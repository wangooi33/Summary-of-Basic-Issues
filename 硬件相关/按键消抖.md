按键消抖常用两大思路：**轮询消抖** 和 **中断 + 软定时器消抖**。结合 STM32 + FreeRTOS，给你两套“能直接用”的实现模板，还顺带把短按/长按/连击一起搞定。

------

# 方案一：任务轮询消抖（简单稳妥）

思路：固定周期读按键电平，只有**连续稳定 N 次**才认为状态改变。

**参数建议**

- 采样周期：5–10 ms（`vTaskDelay(pdMS_TO_TICKS(10))`）
- 稳定次数：3–4 次（≈30–40 ms 防抖时间）
- 长按判定：> 600–800 ms

**状态机（推荐）**

```scss
IDLE(未按) → BOUNCE(抖动确认) → PRESSED(已按下) → HOLD(长按)
               ↑             ↓            ↑
               └──────── RELEASED ←───────┘
```

**示例代码（FreeRTOS 任务版）**

```c
typedef enum {IDLE, BOUNCE, PRESSED, HOLD} key_state_t;

#define KEY_READ()        (GPIO_ReadInputDataBit(GPIOx, GPIO_Pin_y) == 0) // 低电平按下
#define SAMPLE_MS         10
#define DEBOUNCE_COUNT    3      // 3*10ms=30ms消抖
#define LONG_PRESS_MS     800
#define DOUBLE_GAP_MS     300

extern QueueHandle_t inputQueue; // 你的 InputData 队列
extern const uint8_t Key_ID;

void Key_Task(void *arg)
{
    key_state_t st = IDLE;
    uint16_t stable_cnt = 0;
    TickType_t press_tick = 0;
    TickType_t last_release_tick = 0;
    int waiting_double = 0;

    for(;;) {
        bool down = KEY_READ();

        switch(st) {
        case IDLE:
            if (down) { st = BOUNCE; stable_cnt = 1; }
            break;

        case BOUNCE:
            if (down) {
                if (++stable_cnt >= DEBOUNCE_COUNT) {
                    st = PRESSED;
                    press_tick = xTaskGetTickCount();
                }
            } else {
                st = IDLE; // 抖回去了
            }
            break;

        case PRESSED:
            if (!down) {
                // 短按释放
                InputData ev = {.id=Key_ID, .count=1}; // 1=短按
                xQueueSend(inputQueue, &ev, 0);

                last_release_tick = xTaskGetTickCount();
                waiting_double = 1;           // 开启双击窗口
                st = IDLE;
            } else {
                if (xTaskGetTickCount() - press_tick >= pdMS_TO_TICKS(LONG_PRESS_MS)) {
                    st = HOLD;
                    // 触发一次“长按开始”事件（可选）
                    InputData ev = {.id=Key_ID, .count=2}; // 2=长按
                    xQueueSend(inputQueue, &ev, 0);
                }
            }
            break;

        case HOLD:
            if (!down) {
                // 长按释放（可选发事件）
                st = IDLE;
            }
            break;
        }

        // 双击判定窗口：在释放后的 300ms 内如果又侦测到一次短按，则发“双击”
        if (waiting_double) {
            if (xTaskGetTickCount() - last_release_tick > pdMS_TO_TICKS(DOUBLE_GAP_MS)) {
                waiting_double = 0; // 超时未发生第二次按下，认为仅是单击，已在上面发过短按
            } else if (st == PRESSED && down) {
                // 第二次按下发生在窗口内，认定为双击
                waiting_double = 0;
                // 这里为了简化，直接发一个 “双击” 事件
                InputData ev = {.id=Key_ID, .count=3}; // 3=双击
                xQueueSend(inputQueue, &ev, 0);
            }
        }

        vTaskDelay(pdMS_TO_TICKS(SAMPLE_MS));
    }
}
```

**优点**

- 简单直观、鲁棒性高；
- 不依赖中断，适合少量按键。

**注意**

- 任务周期不要太短（<5ms）以免 CPU 空转；
- 多键可复用此模板，或做成表驱动数组。

------

# 方案二：外部中断 + 一次性软件定时器（专业高效）

思路：按键触发 EXTI 中断后**先不立刻判定**，而是**关中断并启动一个 one-shot 软定时器（20–30ms）**；到期在回调里再次读电平、确认稳定，再恢复中断。这样既响应快又稳。

**时序**

1. 下降沿进 EXTI → 禁用该 EXTI → 启动 `xTimerStart(one_shot, 0)`
2. 定时器回调（20ms 后）读脚位：
   - 若仍为按下：确认按下事件，记录按下时间；
   - 若已弹起：抖动误触，丢弃；
   - 最后 **重新打开 EXTI**。

**示例代码（中断 + 软定时器）**

```c
static TimerHandle_t xKeyDebounceTim;
static volatile uint8_t key_pending = 0;

static void vKeyDebounceCb(TimerHandle_t xTimer)
{
    if (GPIO_ReadInputDataBit(GPIOx, GPIO_Pin_y) == 0) {
        // 确认按下
        InputData ev = {.id=Key_ID, .count=1}; // 或先记录按下时间做长按
        xQueueSendFromISR(inputQueue, &ev, NULL);
    }
    key_pending = 0;
    EXTI->IMR |= EXTI_LineY; // 重新使能中断（按你的芯片库写）
}

void EXTIy_IRQHandler(void)
{
    if (EXTI_GetITStatus(EXTI_LineY) != RESET) {
        if (!key_pending) {
            key_pending = 1;
            EXTI->IMR &= ~EXTI_LineY; // 暂时关本线中断
            xTimerStartFromISR(xKeyDebounceTim, NULL); // 20-30ms后判断
        }
        EXTI_ClearITPendingBit(EXTI_LineY);
    }
}

void Key_Init(void)
{
    // ... GPIO/EXTI 初始化
    xKeyDebounceTim = xTimerCreate("keydeb", pdMS_TO_TICKS(25),
                                   pdFALSE, NULL, vKeyDebounceCb);
}
```

**优点**

- 响应快、CPU 占用低；
- 适合大量按键或功耗敏感场景（大部分时间 MCU 可睡眠，靠 EXTI 唤醒）。

**扩展**

- 在回调里加长按计时（用另一个周期定时器或记录 Tick）；
- 支持上升/下降沿分别处理按下/释放。

------

# 硬件消抖（可选叠加）

- **RC 滤波**：串一个 100Ω–1kΩ 电阻，接个 0.1µF 电容到地（与输入并联），等效 10–100µs 的硬件滤波；
- **施密特触发输入**：选用带施密特的 GPIO 或外接 74HC14；
- **上拉/下拉**：确保静止电平稳定（内部或外部电阻 10kΩ 左右）。

> 硬件 + 软件 双重消抖是量产里最稳的做法。

------

# 项目对接建议（与你的代码风格一致）

你的工程里已经用 **队列 `inputQueue`** 把输入事件（编码器/按键）发给菜单任务和串口任务。建议把上面的“任务轮询消抖”或“中断+定时器消抖”封装为**独立 Key_Task**，向 `inputQueue` 推送：

- `count=1`：短按
- `count=2`：长按
- `count=3`：双击
- 也可用 `id=Key_ID` 区分来源，与你现有的 `MenuShow_Task` / `Serial_Task` 无缝对接。

------

# 快速选择指引

- 想要**最快落地**：用 **方案一（轮询）**；
- 想要**低功耗/高响应**：用 **方案二（EXTI+一次性软定时器）**；
- 量产&最稳：**硬件 + 软件** 双消抖，配合 **状态机** 做短按/长按/双击。