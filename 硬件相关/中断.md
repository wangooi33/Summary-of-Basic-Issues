**中断可以嵌套**



| 模块     | 全称                                 | 作用                                            |
| -------- | ------------------------------------ | ----------------------------------------------- |
| `SYSCFG` | System Configuration Controller      | **配置中断源和通道映射**（如 GPIO 映射到 EXTI） |
| `EXTI`   | External Interrupt/Event Controller  | **检测外部事件并生成中断请求**                  |
| `NVIC`   | Nested Vectored Interrupt Controller | **管理中断优先级、开启/屏蔽中断、响应中断**     |



```c
#include "stm32f4xx.h"  //必须包含

//前台程序就是中断服务程序，该程序是不需要手动调用的，当中断触发之后CPU会自动跳转过来执行该函数
void EXTI0_IRQHandler(void)
{
	//判断边沿检测器0的中断是否触发
  	if(EXTI_GetITStatus(EXTI_Line0) != RESET)
  	{
		//执行前台程序，比如按下按键就会触发中断，中断执行蜂鸣器的鸣叫
   		GPIO_ResetBits(GPIOF,GPIO_Pin_9);//控制PF9引脚输出低电平，则LED会亮
   
    	//清除边沿检测器0的中断状态，目的是为了下次可以顺利触发中断
    	EXTI_ClearITPendingBit(EXTI_Line0);
  	}
}

//LED的初始化
void  LED_Config()
{
	//1.定义GPIO外设的结构体变量
	GPIO_InitTypeDef  GPIO_InitStructure;
	
	//2.打开GPIOF端口的时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
	
	//3.配置PF9引脚为输出模式
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	
	//4.对GPIOF端口进行初始化
	GPIO_Init(GPIOF, &GPIO_InitStructure);
	
	GPIO_SetBits(GPIOF,GPIO_Pin_9);//LED不亮
}

void KEY_Config()
{
	//1.定义外设的初始化结构体变量
	EXTI_InitTypeDef   EXTI_InitStructure;
  	GPIO_InitTypeDef   GPIO_InitStructure;
  	NVIC_InitTypeDef   NVIC_InitStructure;
	
	//2.打开GPIOA+SYSCFG的时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,  ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

	//3.配置PA0引脚为输入模式，如果打算检测PA0引脚的边沿，必须配置为输入模式
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	//4.把EXTI0外部中断线和PA0引脚建立映射关系
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource0);
	
    
	//5.配置EXTI0外部中断线的参数
	EXTI_InitStructure.EXTI_Line = EXTI_Line0;				//边沿检测器编号，编号需要和引脚编号一致
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;		//中断模式，当检测到指定边沿可以触发中断
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //检测边沿，下降沿是用户按下按键才会生成
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;			  //边沿检测器的状态，ENABLE是启用  DISABLE是禁用
	EXTI_Init(&EXTI_InitStructure);

	//6.配置NVIC外设的参数+初始化NVIC
    //NVIC利用4bit的优先级来管理所有的中断通道，STM32中断的优先级分为两种：抢占式优先级（主优先级） + 响应式优先级（子优先级），每种都有16个优先级（0~15），**数字越小，优先级越高。**
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;	     //中断通道，每个边沿检测器都有独立的通道
  	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//中断的抢占优先级  范围 0 ~ 15
  	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;       //中断的子优先级    范围 0 ~ 15
  	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;		    //中断通道的状态  ENABLE是启用  DISABLE是禁用
	NVIC_Init(&NVIC_InitStructure);
}

int main()
{
	
	//1.硬件的初始化
	LED_Config();  
	KEY_Config();
	
	while(1)
	{
		
	}
}
```

