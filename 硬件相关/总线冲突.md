## 情况一：**每个 SPI 设备连接独立的 SPI 外设模块（如 SPI1, SPI2）**

比如：

- 设备 A → SPI1 (SCK1, MOSI1, MISO1, CS1)
- 设备 B → SPI2 (SCK2, MOSI2, MISO2, CS2)

### ✔ ✔结论：

不会产生总线冲突。

### ✔✔ 原因：

- 每个设备对应的是**完全独立的 SPI 控制器**；
- 每个 SPI 控制器有自己独立的寄存器、状态机；
- 多任务可以并发访问，只要各自用自己的 `SPIx` 就行，不需要加互斥。

------

##  情况二：**多个 SPI 设备共用一个 SPI 控制器（如都接到 SPI1），CS 不同**

比如：

- 设备 A → SPI1 (共用 SCK, MOSI, MISO)，独立 CS_A
- 设备 B → SPI1 (共用 SCK, MOSI, MISO)，独立 CS_B

### ❗❗结论：

**会有控制器访问冲突，需加互斥锁。**

### ❗❗原因：

- 尽管外设不同，但控制器（SPI1）是同一个；
- 多任务同时访问 SPI1，会造成寄存器覆盖、状态机混乱；
- 必须串行化访问 SPI1，使用互斥信号量保护；

### ❗❗分析：

#### ✅ 1. **理论上：片选生效，其他外设确实不会响应**

当我们对某个 SPI 外设拉低片选（CS）引脚时：

- 只有被片选的设备会响应 SPI 总线上的数据；
- 没有被片选的外设会“休眠”或忽略信号，不会干扰总线；
- 所以**从设备响应角度看，不存在设备干扰**。

这就是 SPI 协议的设计核心之一：**多设备共享总线**，通过独立 CS 控制。



#### ❗ 2. **但现实问题不止是“设备响应”，而是“驱动行为冲突”**

##### 2.1 多任务并发访问 SPI 控制器，会导致**数据错乱、片选争抢、状态机冲突**

设想以下场景：

- 任务 A 启动 SPI 传输还未完成（DMA、或长数据块传输中）；
- 任务 B 抢占并操作 SPI 控制器，切换了 CS 或重置 SPI；
- 会导致：
  - 设备 A 数据丢失、传输中断；
  - SPI 控制器状态不一致；
  - 两个任务对 SPI 控制寄存器、状态机的**并发访问**，打乱事务。

##### 2.2 举个例子：

```c
// Task A:
CS1_LOW();                 // 拉低片选
SPI_Transmit(bufferA);    // 发送数据还没完...

// 此时 Task B 抢占了 CPU：
CS2_LOW();                 // 改变了片选
SPI_Transmit(bufferB);    // 操作同一个 SPI 寄存器

// 后果：Task A 的传输被干扰，传输数据交叉，通信失败
```

### ❗❗ 对于情况二，需要进行总线冲突处理

```c
// 示例：SPI 控制 OLED 和 SPI Flash，共用 SPI1，CS 不同

SemaphoreHandle_t xSPIMutex = xSemaphoreCreateMutex();

void Task_Display()
{
    xSemaphoreTake(xSPIMutex, portMAX_DELAY);
    SPI1_Select(OLED_CS);
    SPI1_SendData(...);
    xSemaphoreGive(xSPIMutex);
}

void Task_Flash()
{
    xSemaphoreTake(xSPIMutex, portMAX_DELAY);
    SPI1_Select(FLASH_CS);
    SPI1_ReadData(...);
    xSemaphoreGive(xSPIMutex);
}
```

------

## 总结：

如果每个设备连接在不同的 SPI 控制器上（如 SPI1、SPI2），它们是物理独立的，无需互斥访问。但在实际项目中，通常多个 SPI 设备会共用一个控制器（如 SPI1），只通过不同的片选 CS 区分，此时它们共用 MOSI/MISO/SCK 总线，会发生总线冲突。因此应使用 FreeRTOS 的互斥信号量来保护对 SPI 控制器的访问，确保任务间访问的时序安全。